#pragma once

#include "Precompile.h"


namespace Algorithm::Sort
{

    /*
    Алгоритм:
    Задача заключается в следующем: есть часть массива, которая уже отсортирована,
    и требуется вставить остальные элементы массива в отсортированную часть,
    сохранив при этом упорядоченность.
    Для этого на каждом шаге алгоритма мы выбираем один из элементов входных данных и
    вставляем его на нужную позицию в уже отсортированной части массива,
    до тех пор пока весь набор входных данных не будет отсортирован.
    Метод выбора очередного элемента из исходного массива произволен,
    однако обычно (и с целью получения устойчивого алгоритма сортировки),
    элементы вставляются по порядку их появления во входном массиве.

    Так как в процессе работы алгоритма могут меняться местами только соседние элементы,
    каждый обмен уменьшает число инверсий на единицу.
    Следовательно, количество обменов равно количеству инверсий в
    исходном массиве вне зависимости от реализации сортировки.
    Максимальное количество инверсий содержится в массиве,
    элементы которого отсортированы по невозрастанию.
    Число инверсий в таком массиве n * (n−1)^2.

    Алгоритм работает за O(n+k),
    где k — число обменов элементов входного массива, равное числу инверсий.
    В среднем и в худшем случае — за O(n^2).
    Минимальные оценки встречаются в случае уже
    упорядоченной исходной последовательности элементов,
    наихудшие — когда они расположены в обратном порядке. 
    */

    /// @brief 
    /// @param arr 
    void InsertionSort(std::vector<int>& arr)
    {
        if (arr.empty() || arr.size() == 1)
            return;
        
        for (size_t i = 1; i < arr.size(); ++i)
            for( size_t j = i; j > 0 && arr.at(j) < arr.at(j - 1); --j)
                    std::swap(arr.at(j), arr.at(j - 1));
    }

    /*
    Оптимизации.
    Бинарные вставки

    Теперь вместо линейного поиска позиции мы будем использовать бинарный поиск,
    следовательно количество сравнений изменится с O(N^2) до O(N * log(N)).
    Количество сравнений заметно уменьшилось, но для того,
    чтобы поставить элемент на своё место,
    всё ещё необходимо переместить большое количество элементов.
    В итоге время выполнения алгоритма в асимптотически не уменьшилось.
    Бинарные вставки выгодно использовать только в случае когда сравнение занимает много времени по сравнению со сдвигом.
    Например когда мы используем массив длинных чисел. 
    */

    /// @brief 
    /// @param arr 
    void BinaryInsertionSort(std::vector<int>& arr)
    {
        if (arr.empty() || arr.size() == 1)
            return;
        
        for (size_t i = 1; i < arr.size(); ++i)
            for( size_t j = i; j > 0 && arr.at(j) < arr.at(j - 1); --j)
                    std::swap(arr.at(j), arr.at(j - 1));
    }
}